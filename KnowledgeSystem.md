# 知识体系

## 测试

### 测例的格式

| 项目         | 内容 |
|------------|------|
| 编号         |      |
| 测试目的     |      |
| 前置条件     |      |
| 输入         |      |
| 期望输出     |      |
| 后置条件     |      |
| 执行过程记录 |      |
| 测试日期     |      |
| 软件版本     |      |
| 测试执行者   |      |
| 测试结果     |      |

### 测试的范围

* 规格说明书所描述的期望行为
* 程序实际执行的行为
* 测试用例覆盖到的行为

### 测试类型

#### 功能测试

黑盒测试：只根据规格说明书编写的测试。确认规定行为都已实现。建立可信度。

方法：

| 方法         | 说明                                                                 |
|------------|--------------------------------------------------------------------|
| 边界值分析   | 利用输入变量的最小值，略大于最小值的值，正常值，略小于最大值的值，最大值 |
| 健壮性测试   | 超出输入范围，输入略大于最大值的值，略小于最小值的值                   |
| 最坏情况分析 | 将所有输入变量的边界值组合在一起，做笛卡尔积                          |
| 特殊值测试   | 来自经验与知识获得的特殊值                                           |
| 随机测试     | 根据输入边界设定随机数范围                                           |
| 等价类测试   | 进行某种意义上完备的测试，并尽可能减少冗余测试                        |
| 基于决策表   | 最为严格的的测试，根据输入与输出画决策矩阵                            |

#### 结构测试

白盒测试：基于程序的设计编写的测试。规避未定义行为。找出故障。

| 方法       | 说明             |
|----------|------------------|
| 路径测试   | 画代码决策路径图 |
| 数据流测试 |                  |

#### 性能测试

系统监控

性能分析：perf 火焰图

测试工具：loadrunner jmeter benchmarksql sysbench

测试模型

#### 交互性测试



### 测试的层次

| 层级         | 测试     |
|------------|----------|
| 需求规格说明 | 系统测试 |
| 概要设计     | 集成测试 |
| 详细设计     | 单元测试 |
| 编码         |          |

## 数据库

### 数据库的意义

直接用文件系统储存组织信息的弊端：

* 冗余：相同的信息可能存储在多个文件中
* 不一致：冗余存储的信息很可能得不到同步更新，而导致最终数据不一致
* 访问困难：传统文件处理环境不支持一种方便高效的方式获取所需数据
* 数据孤立：数据分散在不同文件中，难以进行快速检索
* 完整性：难以保证一些一致性约束
* 原子性：难以保证数据的更新是原子操作
* 并发访问：多用户访问同一数据进行修改时，容易产生错误结果
* 安全性：所有能访问文件所在计算机的用户都能查看文件内容‘’

### 数据抽象

1. 物理层：数据实际是如何存储的
2. 逻辑层：数据与数据之间的关系模型（数据库中的数据关系，DBA需要掌握）
3. 视图层：从逻辑层中提取部分再进一步抽象（用户访问数据库时，只需要关心自己所需的那一部分数据）

### 实例与模式

1. 实例：数据库系统中信息的集合
2. 模式：数据库的总体设计
    1. 物理模式
    2. 逻辑模式

应用程序不需要依赖物理模式，只需要依赖逻辑模式。

### 数据模型

描述数据、数据联系、数据语义以及一致性约束的概念集合。提供了一种描述物理层、逻辑层、视图层数据库设计的方式。

1. 关系模型：
2. 实体-联系模型
3. 基于对象的模型
4. 半结构化模型

### 数据库语言

1. DML 数据操纵语言
2. DDL 数据定义语言
3. DQL

### 关系数据库

表

### 数据库设计

### 存储和查询

#### 存储

组件：

1. 权限和完整性
2. 事务
3. 文件管理
4. 缓冲区管理

数据结构：

1. 数据文件
2. 数据字典：元数据
3. 索引：便于快速访问

#### 查询执行

优化器：

1. 接收并验证SQL语句的语法语义
2. 分析环境并优化满足SQL语句的方法
3. 创建计算机可读指令来执行优化的SQL
4. 执行指令或存储指令直到执行

语句执行流程：

1. 语法分析：是否有语法错误
2. 语义检查：语义是否正确，如是否有相应的表相应的列
3. 查询重写：将一条语句改写成更高效的语义等价语句
4. 优化访问计划
5. 生成可执行代码
6. 执行访问计划

解释器

执行引擎

### 事务管理

事务：完成单一逻辑功能的操作集合。

A：原子不可分
C：保证一致性约束
I：隔离并发互相不影响
D：持久不丢失

恢复管理器：保证A、D
并发控制管理器：保证I

#### 事务隔离与锁

基于行锁，与两阶段锁。

两阶段锁：一个事务之内分为两个阶段，加锁阶段和解锁阶段，加锁阶段在前只能加锁，解锁阶段在后只能解锁，在事务结束后完成解锁。

排他锁：禁止读写行为。

共享锁：禁止写不禁止读。

| 等级                 | 描述                                                                    | 解决问题             |
|--------------------|-----------------------------------------------------------------------|--------------------|
| 一级锁（RU）           | 写操作前上排他锁，事务结束才可释放排他锁                                 | 脏写                 |
| 二级锁（RC）           | 写操作前上排他锁，读操作上共享锁，读完可释放共享锁，事务结束才可释放排他锁 | 脏写，脏读            |
| 三级锁（Serializable） | 写操作前上排他锁，读操作上共享锁，事务结束才可释放排他锁和共享锁          | 脏读，脏写，不可重复读 |

RR隔离级的定义比较模糊，各个数据库并没有达成统一实现。

幻读需要间隙锁来解决。

#### 事务隔离与MVCC

1. 每个事务都有全局唯一的trx_id
2. 写入数据库的每条记录，都应有隐藏列trx_id作为版本号，记录的可读性由版本号与当前事务的trx_id之间的关系决定。

trx_id有序的情况下：

| 解决问题   | 具体操作                                                           |
|----------|----------------------------------------------------------------|
| 脏写       | 已有记录的版本号大于当前trx_id时无法写入新的记录                   |
| 脏读       | 只能读到版本号小于等于当前trx_id的数据                             |
| 不可重复读 | 第一次读取数据时，记录记录的版本号，再次读取时还是读取这个版本的数据 |

新的隔离级：

| 等级              | 描述                                                                             | 解决问题                        | 存在问题                                                                                                                               |
|-----------------|--------------------------------------------------------------------------------|-----------------------------|----------------------------------------------------------------------------------------------------------------------------------------|
| 快照隔离SI        | 一个事务中所有读操作读到的数据，要么是事务一开始时的版本，要么是本事务内修改的版本 | 脏读，脏写，不可重复读            | 写倾斜：两个写事务分别更新具有一致性约束的不同列，可能会导致最终提交的数据破坏了一致性约束，这一点需要应用程序额外处理（select for update） |
| 序列化快照隔离SSI | 在SI基础上，对读写依赖进行检测，杀死可能会导致anomaly的事务，不过可能存在误杀       | 效果上等同序列化，拥有更好的性能 |                                                                                                                                        |


#### 分布式事务

分布式时序：

1. 同时
2. 先后：因果，时间戳差距超过时钟误差

两阶段提交(保证原子性)：

1. prepare
2. commit

分布式事务模型：

### 数据挖掘与信息检索

数据挖掘：分析大型数据库并从中找出有用的模式

数据仓库：从多个来源收集数据，建立统一的模式


解析

优化器

事务

存储

### 分布式数据库

#### shard

将一组存储不同数据的服务器，通过联邦模式连接一起对外提供服务，被称为shard。

1. 高可用：单台服务器故障，其他服务器上的数据仍可对外提供服务
2. 更高效的查询：如果shard中的数据分散是有规律的，那么范围查询与定点查询，就可以定位到具体的一台服务器上进行。
3. 更高的写入带宽：能够多台服务器并行写入，提高写入吞吐。


#### partition

## 数据库测试

### 解析器



#### fuzz

sqlsmith

RQG

pquery

### 事务

ACID

隔离级

### 优化器

1. 结果是否正确
2. 优化是否有效果
    * 展示出的执行计划与实际执行计划的出入
    * 开关优化选项，对比性能
    * 准备不同场景下的数据集，均匀的，非均匀的
    * 高并发情况下是否性能依旧更好

https://github.com/chaos-mesh/horoscope

#### 计划类型

##### 逻辑计划


##### 物理计划

基本算子：

| 类型       | 说明                 |
|------------|--------------------|
| Scan       | 读取数据源中具体数据 |
| Selection  | 根据谓词条件过滤数据 |
| Join       | 将两个表的数据连接   |
| Projection | 向外输出数据         |

其中Scan在最底层，Projection在最顶层。

- pull 火山模型：从上到下一层一层fetch数据，将每个算子都抽象成了迭代器，具有Next方法。一种优先照顾IO效率，没有优化CPU效率的方法。

- push Pipeline：先从底层算子开始执行，算子执行结束之后，将数据推送给上层算子，通知上层算子开始执行。上下文切换比较少，对CPU cache比较友好，更适合大数据场景。

#### 衡量标准

1. 生成执行计划的质量：一条语句的正确执行计划一般都有很多种，枚举这些执行计划并根据执行效率排序，就可以得出优化器生产的执行计划具体的效率排名。
2. 生成执行计划所消耗的代价：需要多少计算机资源与时间才能得出这样的执行计划。

#### A/B test

将应用程序的两个版本相互比较来确定性能更好的版本。

流程：

1. 确定测试目标：新版本比旧版本改善的部分应该用哪些指标来评判
2. 设计测例
3. 执行测试
4. 对比结果

#### join

* 语法

| 类型                    | 描述                                                                                                                                      |
|-------------------------|-----------------------------------------------------------------------------------------------------------------------------------------|
| cross join              | 没有匹配条件，完全是笛卡尔积                                                                                                               |
| （inner）join             | 根据匹配条件做笛卡尔积，求交集                                                                                                             |
| left/right (outer) join | 两表符合匹配条件的部分做笛卡尔积，不符合的部分左/又表保留所有行，另一张表为NULL                                                             |
| full (outer) join       | 两表符合匹配条件的部分做笛卡尔积，不符合的部分一张表保留所有行，另一张表为NULL，求两表并集。full join是left join 和right join 经过union的结果 |
| semi-join/anti-join     | 非标准SQL语法，主要用于查询优化器内部。只关心右表中是否存在与左表能够连接的记录，并返回相应的左表记录                                        |
| straight join           | mysql语法，能够指定以左表作为驱动表                                                                                                        |
| natural jon             | mysql 自己判断连接过程，不需要指定连接条件，mysql会使用表内相同的字段作为连接条件，有内外之分                                                |

* 实现

| 概念     | 描述                                                     |
|--------|--------------------------------------------------------|
| 驱动表   | 外层循环，从中依次取出每条记录，在内层循环中寻找相应的记录 |
| 被驱动表 | 内层循环                                                 |


| 类型             | 描述                                                                                                                  |
|------------------|---------------------------------------------------------------------------------------------------------------------|
| Nested loop join | 外层循环驱动表进行遍历，在内层循环被驱动表的过程中，找到两表匹配的行。被驱动表的匹配行上最好有顺序索引，可以提高执行效率。 |
| （Sort）Merge join|驱动表与被驱动表的匹配列上都有相同的顺序索引，根据索引找到第一个匹配行，然后同时向下遍历驱动表和被驱动表     |                                                                                                                       |
| Hash join        |选小表作为驱动表，对条件列做hash表；对被驱动表，对条件列做hash，这样分别扫描驱动表与被驱动表一次就可以找到匹配列完成join。内存不够时，可以用hash进行partition操作，逐个partition完成join操作。|



### 一致性

Jepsen

混沌测试：

| 故障类型      | 注入方法            |
|-------------|---------------------|
| 网络连接故障  | iptables            |
| 网络延迟、带宽 | tc                  |
| 停机          | kill杀进程，杀死容器 |
| 时间倾斜      |                     |
| 内核bug       |                     |

### 安全测试

加密

三权分立
